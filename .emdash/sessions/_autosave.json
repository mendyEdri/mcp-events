{
  "name": "_autosave",
  "messages": [
    {
      "role": "tool",
      "tool_call_id": " functions.enter_plan_mode:67",
      "content": "{\"success\": true, \"data\": {\"status\": \"plan_mode_requested\", \"reason\": \"User wants to plan two new time-based delivery channels (cron and scheduled) for the MCPE protocol. This requires architectural planning for protocol extensions, storage, scheduling mechanism, and integration with existing delivery coordinator.\", \"message\": \"Plan mode requested. Waiting for user approval.\"}, \"error\": null, \"suggestions\": [], \"metadata\": {}}"
    },
    {
      "role": "assistant",
      "content": "   ",
      "tool_calls": [
        {
          "id": "  functions.write_todo:68",
          "type": "function",
          "function": {
            "name": "write_todo",
            "arguments": "{\"title\": \"Design Time-Based Delivery Architecture\", \"description\": \"Plan the architecture for time-based delivery channels including ScheduledDelivery types, ScheduleStore interface, and Scheduler service\"}"
          }
        },
        {
          "id": "  functions.write_todo:69",
          "type": "function",
          "function": {
            "name": "write_todo",
            "arguments": "{\"title\": \"Plan Cron-Based Channel\", \"description\": \"Design the cron-based delivery channel for recurring schedules (every hour, daily, weekly, etc) with cron expression support\"}"
          }
        },
        {
          "id": "  functions.write_todo:70",
          "type": "function",
          "function": {
            "name": "write_todo",
            "arguments": "{\"title\": \"Plan One-Time Scheduled Channel\", \"description\": \"Design the one-time scheduled delivery channel for future events (remind me in 4 hours, next Sunday, etc) with timestamp and natural language parsing\"}"
          }
        }
      ]
    },
    {
      "role": "tool",
      "tool_call_id": "  functions.write_todo:68",
      "content": "{\"success\": true, \"data\": {\"task\": {\"id\": \"task-343d638e\", \"title\": \"Design Time-Based Delivery Architecture\", \"description\": \"Plan the architecture for time-based delivery channels including ScheduledDelivery types, ScheduleStore interface, and Scheduler service\", \"status\": \"pending\", \"depends_on\": [], \"labels\": [], \"claimed_by\": null, \"claimed_at\": null, \"created_at\": \"2026-02-03T15:30:49.030706\", \"updated_at\": \"2026-02-03T15:30:49.030706\", \"created_by\": \"session-8f6d0408\", \"priority\": 0, \"order\": 8, \"version\": 1}, \"task_id\": \"task-343d638e\", \"labels\": [], \"depends_on\": [], \"task_list\": \"default\", \"total_tasks\": 9, \"message\": \"Created task 'Design Time-Based Delivery Architecture'\"}, \"error\": null, \"suggestions\": [], \"metadata\": {}}"
    },
    {
      "role": "tool",
      "tool_call_id": "  functions.write_todo:69",
      "content": "{\"success\": true, \"data\": {\"task\": {\"id\": \"task-1da0cd41\", \"title\": \"Plan Cron-Based Channel\", \"description\": \"Design the cron-based delivery channel for recurring schedules (every hour, daily, weekly, etc) with cron expression support\", \"status\": \"pending\", \"depends_on\": [], \"labels\": [], \"claimed_by\": null, \"claimed_at\": null, \"created_at\": \"2026-02-03T15:30:48.974480\", \"updated_at\": \"2026-02-03T15:30:48.974480\", \"created_by\": \"session-8f6d0408\", \"priority\": 0, \"order\": 7, \"version\": 1}, \"task_id\": \"task-1da0cd41\", \"labels\": [], \"depends_on\": [], \"task_list\": \"default\", \"total_tasks\": 8, \"message\": \"Created task 'Plan Cron-Based Channel'\"}, \"error\": null, \"suggestions\": [], \"metadata\": {}}"
    },
    {
      "role": "tool",
      "tool_call_id": "  functions.write_todo:70",
      "content": "{\"success\": true, \"data\": {\"task\": {\"id\": \"task-e7028bdd\", \"title\": \"Plan One-Time Scheduled Channel\", \"description\": \"Design the one-time scheduled delivery channel for future events (remind me in 4 hours, next Sunday, etc) with timestamp and natural language parsing\", \"status\": \"pending\", \"depends_on\": [], \"labels\": [], \"claimed_by\": null, \"claimed_at\": null, \"created_at\": \"2026-02-03T15:30:49.034378\", \"updated_at\": \"2026-02-03T15:30:49.034378\", \"created_by\": \"session-8f6d0408\", \"priority\": 0, \"order\": 9, \"version\": 1}, \"task_id\": \"task-e7028bdd\", \"labels\": [], \"depends_on\": [], \"task_list\": \"default\", \"total_tasks\": 10, \"message\": \"Created task 'Plan One-Time Scheduled Channel'\"}, \"error\": null, \"suggestions\": [], \"metadata\": {}}"
    },
    {
      "role": "assistant",
      "content": "  Since you want me to **just plan** (not implement), I'll create a comprehensive architectural design document for these two time-based delivery channels.\n\n---\n\n# \ud83d\udccb PLAN: Time-Based Delivery Channels for MCPE\n\n## **Executive Summary**\n\nAdd two new delivery channels that operate on **time-based triggers** rather than immediate event matching:\n1. **Cron-Based Channel** - Recurring schedules (every hour, daily, weekly)\n2. **Scheduled Channel** - One-time future events (remind me in 4 hours, next Sunday)\n\nThese channels **delay event delivery** until a specific time condition is met.\n\n---\n\n## **1. Architecture Overview**\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         EXISTING SYSTEM                                      \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n\u2502  \u2502   Event     \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502   Subscription  \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502   DeliveryCoordinator\u2502       \u2502\n\u2502  \u2502   Source    \u2502      \u2502   Manager       \u2502      \u2502   (immediate)        \u2502       \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n\u2502                                                        \u2502                      \u2502\n\u2502                           EVENT MATCHES FILTER         \u2502                      \u2502\n\u2502                               (immediate)              \u25bc                      \u2502\n\u2502                                              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502\n\u2502                                              \u2502 WebSocket / APNS \u2502            \u2502\n\u2502                                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         NEW: TIME-BASED SYSTEM                               \u2502\n\u2502                                                                               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502                     ScheduleStore (new)                               \u2502  \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u2502\n\u2502  \u2502  \u2502  Cron Schedule  \u2502  \u2502 One-Time Schedule\u2502  \u2502   Schedule Job Queue   \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  (recurring)    \u2502  \u2502  (future date)   \u2502  \u2502   (Redis/Bull/etc)     \u2502  \u2502  \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                    \u25b2                                          \u2502\n\u2502                                    \u2502                                          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502                     SchedulerService (new)                            \u2502  \u2502\n\u2502  \u2502  \u2022 Evaluates cron expressions                                         \u2502  \u2502\n\u2502  \u2502  \u2022 Manages job queue                                                  \u2502  \u2502\n\u2502  \u2502  \u2022 Triggers delivery when time condition met                          \u2502  \u2502\n\u2502  \u2502  \u2022 Handles rescheduling for recurring jobs                            \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                    \u2502                                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                    \u2502                                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502                  TIME-BASED DELIVERY FLOW                              \u2502  \u2502\n\u2502  \u2502                                                                        \u2502  \u2502\n\u2502  \u2502  1. Agent creates subscription with time-based delivery                \u2502  \u2502\n\u2502  \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502  \u2502\n\u2502  \u2502     \u2502 subscription/create                                        \u2502     \u2502  \u2502\n\u2502  \u2502     \u2502   filter: { sources: [\"reminder\"], type: \"reminder.due\" }  \u2502     \u2502  \u2502\n\u2502  \u2502     \u2502   delivery: {                                              \u2502     \u2502  \u2502\n\u2502  \u2502     \u2502     channels: [\"scheduled\"],                               \u2502     \u2502  \u2502\n\u2502  \u2502     \u2502     schedule: {                                            \u2502     \u2502  \u2502\n\u2502  \u2502     \u2502       type: \"cron\",                                        \u2502     \u2502  \u2502\n\u2502  \u2502     \u2502       expression: \"0 9 * * 1-5\"  // 9am weekdays           \u2502     \u2502  \u2502\n\u2502  \u2502     \u2502     }                                                      \u2502     \u2502  \u2502\n\u2502  \u2502     \u2502   }                                                        \u2502     \u2502  \u2502\n\u2502  \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502  \u2502\n\u2502  \u2502                                                                        \u2502  \u2502\n\u2502  \u2502  2. SubscriptionManager saves to ScheduleStore (NOT subscription store)  \u2502  \u2502\n\u2502  \u2502                                                                        \u2502  \u2502\n\u2502  \u2502  3. SchedulerService adds job to queue with trigger time               \u2502  \u2502\n\u2502  \u2502                                                                        \u2502  \u2502\n\u2502  \u2502  4. When trigger time arrives \u2192 Scheduler creates \"synthetic event\"     \u2502  \u2502\n\u2502  \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502  \u2502\n\u2502  \u2502     \u2502 {                                                           \u2502     \u2502  \u2502\n\u2502  \u2502     \u2502   id: \"evt-scheduled-uuid\",                                 \u2502     \u2502  \u2502\n\u2502  \u2502     \u2502   type: \"schedule.triggered\",                               \u2502     \u2502  \u2502\n\u2502  \u2502     \u2502   data: {                                                   \u2502     \u2502  \u2502\n\u2502  \u2502     \u2502     originalSubscriptionId: \"sub-abc123\",                    \u2502     \u2502  \u2502\n\u2502  \u2502     \u2502     scheduledAt: \"2025-01-15T09:00:00Z\",                    \u2502     \u2502  \u2502\n\u2502  \u2502     \u2502     trigger: \"cron:0 9 * * 1-5\"                             \u2502     \u2502  \u2502\n\u2502  \u2502     \u2502   },                                                        \u2502     \u2502  \u2502\n\u2502  \u2502     \u2502   metadata: { source: \"schedule\", priority: \"normal\" }       \u2502     \u2502  \u2502\n\u2502  \u2502     \u2502 }                                                           \u2502     \u2502  \u2502\n\u2502  \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502  \u2502\n\u2502  \u2502                                                                        \u2502  \u2502\n\u2502  \u2502  5. Synthetic event routed through normal DeliveryCoordinator          \u2502  \u2502\n\u2502  \u2502                                                                        \u2502  \u2502\n\u2502  \u2502  6. For recurring schedules \u2192 Scheduler re-queues next occurrence       \u2502  \u2502\n\u2502  \u2502                                                                        \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n---\n\n## **2. Core Protocol Changes**\n\n### **2.1 New Delivery Channel Types**\n\n```typescript\n// packages/core/src/types/subscriptions.ts\n\n// Extend DeliveryChannel enum\nexport const DeliveryChannelSchema = z.enum([\n  'websocket',\n  'sse', \n  'webpush',\n  'apns',\n  'cron',        // \u2190 NEW: Recurring time-based\n  'scheduled',   // \u2190 NEW: One-time time-based\n]);\n\n// NEW: Schedule configuration\nexport const ScheduleTypeSchema = z.enum(['cron', 'onetime']);\n\nexport const CronScheduleSchema = z.object({\n  type: z.literal('cron'),\n  expression: z.string(),              // \"0 9 * * 1-5\" (cron format)\n  timezone: z.string().optional(),     // \"America/New_York\" (IANA timezone)\n  startDate: z.string().datetime().optional(),  // When to start recurring\n  endDate: z.string().datetime().optional(),    // When to stop recurring\n  maxOccurrences: z.number().optional(),      // Max times to fire\n});\n\nexport const OneTimeScheduleSchema = z.object({\n  type: z.literal('onetime'),\n  executeAt: z.string().datetime(),    // ISO 8601 timestamp\n  // OR natural language (server parses)\n  naturalLanguage: z.string().optional(), // \"in 4 hours\", \"next Sunday at 9am\"\n});\n\nexport const ScheduleConfigSchema = z.discriminatedUnion('type', [\n  CronScheduleSchema,\n  OneTimeScheduleSchema,\n]);\n\n// Extend DeliveryPreferences\nexport const DeliveryPreferencesSchema = z.object({\n  channels: z.array(DeliveryChannelSchema),\n  priority: DeliveryPrioritySchema.default('normal'),\n  batchInterval: z.number().optional(),\n  apnsAlert: z.boolean().optional(),\n  // NEW: Time-based scheduling\n  schedule: ScheduleConfigSchema.optional(),  // Only when channels include 'cron' or 'scheduled'\n});\n```\n\n### **2.2 New Schedule Store Interface**\n\n```typescript\n// packages/core/src/types/schedules.ts (NEW FILE)\n\nexport interface Schedule {\n  id: string;                    // Schedule ID (not subscription ID)\n  subscriptionId: string;        // Links to parent subscription\n  clientId: string;             // For routing delivery\n  \n  type: 'cron' | 'onetime';\n  status: 'pending' | 'active' | 'paused' | 'completed' | 'failed';\n  \n  // Cron-specific\n  cronExpression?: string;\n  timezone?: string;\n  lastExecutedAt?: string;\n  nextExecutionAt?: string;\n  executionCount: number;\n  maxOccurrences?: number;\n  \n  // One-time specific\n  executeAt?: string;\n  \n  // Metadata\n  createdAt: string;\n  updatedAt: string;\n  \n  // For job queue integration\n  jobId?: string;               // Reference to Bull/Agenda/etc job\n}\n\nexport interface ScheduleStore {\n  // CRUD operations\n  create(schedule: Schedule): Promise<Schedule>;\n  get(id: string): Promise<Schedule | null>;\n  update(id: string, updates: Partial<Schedule>): Promise<Schedule | null>;\n  delete(id: string): Promise<boolean>;\n  \n  // Query operations\n  listByClient(clientId: string): Promise<Schedule[]>;\n  listBySubscription(subscriptionId: string): Promise<Schedule[]>;\n  listPending(before: Date): Promise<Schedule[]>;  // For scheduler polling\n  \n  // Cron-specific\n  getDueCronSchedules(now: Date): Promise<Schedule[]>;  // Next execution <= now\n  incrementExecutionCount(id: string): Promise<void>;\n  \n  // Cleanup\n  cleanupCompleted(before: Date): Promise<number>;  // Remove old completed schedules\n}\n```\n\n---\n\n## **3. Server Package Architecture**\n\n### **3.1 New Components**\n\n```\npackages/server/src/\n\u251c\u2500\u2500 schedules/\n\u2502   \u251c\u2500\u2500 store.ts              # ScheduleStore interface\n\u2502   \u251c\u2500\u2500 memory-store.ts       # In-memory implementation\n\u2502   \u251c\u2500\u2500 index.ts\n\u2502   \u2514\u2500\u2500 __tests__/\n\u251c\u2500\u2500 scheduler/\n\u2502   \u251c\u2500\u2500 scheduler-service.ts   # Main scheduling orchestrator\n\u2502   \u251c\u2500\u2500 cron-evaluator.ts     # Cron expression evaluation\n\u2502   \u251c\u2500\u2500 time-parser.ts        # Natural language time parsing\n\u2502   \u251c\u2500\u2500 job-queue.ts          # Abstract job queue interface\n\u2502   \u251c\u2500\u2500 index.ts\n\u2502   \u2514\u2500\u2500 __tests__/\n\u2514\u2500\u2500 delivery/\n    \u251c\u2500\u2500 coordinator.ts        # Extend with schedule handling\n    \u251c\u2500\u2500 cron-delivery.ts      # Cron channel implementation\n    \u251c\u2500\u2500 scheduled-delivery.ts # One-time channel implementation\n    \u2514\u2500\u2500 apns.ts\n```\n\n### **3.2 Scheduler Service**\n\n```typescript\n// packages/server/src/scheduler/scheduler-service.ts\n\nexport interface SchedulerServiceOptions {\n  scheduleStore: ScheduleStore;\n  jobQueue: JobQueue;                    // Bull, Agenda, or custom\n  deliveryCoordinator: DeliveryCoordinator;\n  pollInterval?: number;                 // Default: 60000ms (1 min)\n  maxConcurrentJobs?: number;            // Default: 10\n}\n\nexport class SchedulerService {\n  private scheduleStore: ScheduleStore;\n  private jobQueue: JobQueue;\n  private deliveryCoordinator: DeliveryCoordinator;\n  private pollTimer: NodeJS.Timeout | null = null;\n  \n  async start(): Promise<void> {\n    // Start polling loop\n    this.pollTimer = setInterval(\n      () => this.checkAndExecuteDueSchedules(),\n      this.options.pollInterval\n    );\n    \n    // Initialize job queue listeners\n    this.jobQueue.on('ready', (job) => this.executeJob(job));\n  }\n  \n  async stop(): Promise<void> {\n    if (this.pollTimer) {\n      clearInterval(this.pollTimer);\n    }\n    await this.jobQueue.close();\n  }\n  \n  /**\n   * Called when subscription with schedule is created\n   */\n  async scheduleSubscription(subscription: Subscription): Promise<Schedule> {\n    const { schedule } = subscription.delivery;\n    if (!schedule) throw new Error('No schedule configuration');\n    \n    // Calculate next execution time\n    const nextExecutionAt = this.calculateNextExecution(schedule);\n    \n    const scheduleRecord: Schedule = {\n      id: uuidv4(),\n      subscriptionId: subscription.id,\n      clientId: subscription.clientId,\n      type: schedule.type,\n      status: 'active',\n      \n      // Cron fields\n      ...(schedule.type === 'cron' && {\n        cronExpression: schedule.expression,\n        timezone: schedule.timezone,\n        nextExecutionAt: nextExecutionAt.toISOString(),\n        executionCount: 0,\n        maxOccurrences: schedule.maxOccurrences,\n      }),\n      \n      // One-time fields\n      ...(schedule.type === 'onetime' && {\n        executeAt: schedule.executeAt,\n      }),\n      \n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    };\n    \n    // Save to store\n    await this.scheduleStore.create(scheduleRecord);\n    \n    // Add to job queue\n    const job = await this.jobQueue.add('schedule-execution', {\n      scheduleId: scheduleRecord.id,\n      executeAt: nextExecutionAt,\n    }, {\n      delay: nextExecutionAt.getTime() - Date.now(),\n    });\n    \n    // Update with job reference\n    await this.scheduleStore.update(scheduleRecord.id, { jobId: job.id });\n    \n    return scheduleRecord;\n  }\n  \n  /**\n   * Execute a scheduled job when its time arrives\n   */\n  private async executeJob(job: Job): Promise<void> {\n    const schedule = await this.scheduleStore.get(job.data.scheduleId);\n    if (!schedule || schedule.status !== 'active') {\n      return; // Skip inactive/deleted schedules\n    }\n    \n    // Create synthetic event\n    const syntheticEvent: ESMCPEvent = {\n      id: uuidv4(),\n      type: `schedule.${schedule.type}`,\n      data: {\n        originalSubscriptionId: schedule.subscriptionId,\n        scheduledAt: schedule.createdAt,\n        executedAt: new Date().toISOString(),\n        executionCount: schedule.executionCount + 1,\n        trigger: schedule.cronExpression || schedule.executeAt,\n      },\n      metadata: {\n        source: 'schedule',\n        priority: 'normal',\n        timestamp: new Date().toISOString(),\n        tags: ['time-based', schedule.type],\n      },\n    };\n    \n    // Get parent subscription\n    const subscription = await this.subscriptionManager.get(schedule.subscriptionId);\n    if (subscription && subscription.status === 'active') {\n      // Deliver through normal coordinator\n      // But we need to deliver to the ORIGINAL subscription's delivery channels\n      // (websocket, apns, etc.) - not the schedule channel itself\n      \n      await this.deliveryCoordinator.deliverToSubscription(\n        syntheticEvent,\n        subscription\n      );\n    }\n    \n    // Update schedule record\n    await this.scheduleStore.update(schedule.id, {\n      lastExecutedAt: new Date().toISOString(),\n      executionCount: schedule.executionCount + 1,\n    });\n    \n    // Handle recurring schedules\n    if (schedule.type === 'cron') {\n      // Check if we should continue\n      const shouldContinue = this.shouldContinueRecurring(schedule);\n      \n      if (shouldContinue) {\n        // Calculate next execution\n        const nextExecutionAt = this.calculateNextExecution({\n          type: 'cron',\n          expression: schedule.cronExpression!,\n          timezone: schedule.timezone,\n        });\n        \n        await this.scheduleStore.update(schedule.id, {\n          nextExecutionAt: nextExecutionAt.toISOString(),\n        });\n        \n        // Re-queue\n        await this.jobQueue.add('schedule-execution', {\n          scheduleId: schedule.id,\n          executeAt: nextExecutionAt,\n        }, {\n          delay: nextExecutionAt.getTime() - Date.now(),\n        });\n      } else {\n        // Mark as completed\n        await this.scheduleStore.update(schedule.id, {\n          status: 'completed',\n        });\n      }\n    } else {\n      // One-time schedule - mark as completed\n      await this.scheduleStore.update(schedule.id, {\n        status: 'completed',\n      });\n    }\n  }\n  \n  /**\n   * Calculate next execution time from schedule config\n   */\n  private calculateNextExecution(schedule: ScheduleConfig): Date {\n    if (schedule.type === 'onetime') {\n      return new Date(schedule.executeAt);\n    }\n    \n    // Use cron-parser or similar library\n    const interval = cronParser.parseExpression(schedule.expression, {\n      currentDate: new Date(),\n      tz: schedule.timezone,\n    });\n    \n    return interval.next().toDate();\n  }\n}\n```\n\n### **3.3 Cron Expression Evaluation**\n\n```typescript\n// packages/server/src/scheduler/cron-evaluator.ts\n\nexport interface CronEvaluator {\n  /**\n   * Parse cron expression and get next execution date\n   */\n  getNextExecution(\n    expression: string,\n    options?: {\n      timezone?: string;\n      currentDate?: Date;\n    }\n  ): Date;\n  \n  /**\n   * Get all execution dates within a range\n   */\n  getExecutionsInRange(\n    expression: string,\n    startDate: Date,\n    endDate: Date,\n    options?: {\n      timezone?: string;\n      maxCount?: number;\n    }\n  ): Date[];\n  \n  /**\n   * Validate if expression is valid cron syntax\n   */\n  validate(expression: string): boolean;\n}\n\n// Implementation would use: node-cron, cron-parser, or later.js\n```\n\n### **3.4 Natural Language Time Parser**\n\n```typescript\n// packages/server/src/scheduler/time-parser.ts\n\nexport interface NaturalLanguageParser {\n  /**\n   * Parse natural language to timestamp\n   * Examples:\n   *   - \"in 4 hours\" \u2192 Date (4 hours from now)\n   *   - \"tomorrow at 9am\" \u2192 Date (next day 9:00 AM)\n   *   - \"next Sunday\" \u2192 Date (upcoming Sunday)\n   *   - \"2025-01-15 14:30\" \u2192 Date (specific datetime)\n   */\n  parse(\n    input: string,\n    options?: {\n      referenceDate?: Date;      // Default: now\n      timezone?: string;         // Default: server timezone\n    }\n  ): Date | null;  // Returns null if parsing fails\n  \n  /**\n   * Validate if input can be parsed\n   */\n  validate(input: string): boolean;\n}\n\n// Implementation could use:\n// - chrono-node (most popular)\n// - compromise/dates (NLP-based)\n// - sugar.js (date parsing)\n// - Custom regex patterns for common cases\n```\n\n---\n\n## **4. Delivery Coordinator Integration**\n\n### **4.1 How Time-Based Channels Differ**\n\n**Current immediate channels** (WebSocket, APNS):\n- Event matches filter \u2192 immediately deliver\n- Synchronous, real-time\n\n**New time-based channels** (cron, scheduled):\n- Event matches filter \u2192 **schedule for future delivery**\n- Asynchronous, queued\n- Creates synthetic event at trigger time\n- Synthetic event delivered through **original channels**\n\n### **4.2 Extended DeliveryCoordinator**\n\n```typescript\n// packages/server/src/delivery/coordinator.ts\n\nexport interface DeliveryCoordinatorOptions {\n  transport: WebSocketServerTransport;\n  apnsDelivery?: APNSDelivery;\n  webPushDelivery?: WebPushDelivery;\n  // NEW:\n  schedulerService: SchedulerService;  // Required for time-based channels\n}\n\nexport class DeliveryCoordinator {\n  // ... existing properties\n  \n  private schedulerService: SchedulerService;\n  \n  async deliver(event: ESMCPEvent, subscriptions: Subscription[]): Promise<DeliveryResult[]> {\n    const results: DeliveryResult[] = [];\n    \n    for (const subscription of subscriptions) {\n      const result = await this.deliverToSubscription(event, subscription);\n      results.push(result);\n    }\n    \n    return results;\n  }\n  \n  private async deliverToSubscription(\n    event: ESMCPEvent,\n    subscription: Subscription\n  ): Promise<DeliveryResult> {\n    const { channels } = subscription.delivery;\n    \n    // Check for time-based channels first\n    if (channels.includes('cron') || channels.includes('scheduled')) {\n      // Don't deliver immediately - schedule it\n      return this.scheduleForLater(event, subscription);\n    }\n    \n    // Existing immediate channels\n    if (channels.includes('websocket')) {\n      // ... try WebSocket\n    }\n    if (channels.includes('apns')) {\n      // ... try APNS\n    }\n    \n    // ...\n  }\n  \n  /**\n   * NEW: Handle time-based scheduling\n   */\n  private async scheduleForLater(\n    event: ESMCPEvent,\n    subscription: Subscription\n  ): Promise<DeliveryResult> {\n    try {\n      // Create schedule from subscription\n      const schedule = await this.schedulerService.scheduleSubscription(subscription);\n      \n      // The actual event delivery will happen later via executeJob()\n      \n      return {\n        subscriptionId: subscription.id,\n        channel: subscription.delivery.channels.includes('cron') ? 'cron' : 'scheduled',\n        success: true,\n        scheduledAt: schedule.type === 'cron' \n          ? schedule.nextExecutionAt \n          : schedule.executeAt,\n      };\n    } catch (error) {\n      return {\n        subscriptionId: subscription.id,\n        channel: 'scheduled',\n        success: false,\n        error: error instanceof Error ? error.message : 'Scheduling failed',\n      };\n    }\n  }\n}\n```\n\n---\n\n## **5. EventHub Integration**\n\n### **5.1 Configuration**\n\n```typescript\n// packages/server/src/hub/hub.ts\n\nexport interface EventHubOptions {\n  port: number;\n  host?: string;\n  // ... existing options\n  \n  // NEW: Time-based scheduling options\n  scheduling?: {\n    enabled: boolean;\n    store?: ScheduleStore;              // Custom store (default: memory)\n    jobQueue?: JobQueue;                // Custom queue (default: in-memory)\n    pollInterval?: number;              // How often to check for due schedules\n    maxConcurrentJobs?: number;\n    cronParser?: CronEvaluator;          // Custom cron parser\n    timeParser?: NaturalLanguageParser; // Custom time parser\n  };\n}\n```\n\n### **5.2 Hub Setup**\n\n```typescript\nexport class EventHub {\n  private transport: WebSocketServerTransport;\n  private subscriptionManager: SubscriptionManager;\n  private deviceStore: DeviceStore;\n  private schedulerService?: SchedulerService;  // NEW\n  private deliveryCoordinator: DeliveryCoordinator;\n  \n  constructor(options: EventHubOptions) {\n    // ... existing setup\n    \n    // NEW: Setup scheduling if enabled\n    if (options.scheduling?.enabled) {\n      const scheduleStore = options.scheduling.store || new MemoryScheduleStore();\n      const jobQueue = options.scheduling.jobQueue || new InMemoryJobQueue();\n      \n      this.schedulerService = new SchedulerService({\n        scheduleStore,\n        jobQueue,\n        deliveryCoordinator: this.deliveryCoordinator,\n        pollInterval: options.scheduling.pollInterval,\n        maxConcurrentJobs: options.scheduling.maxConcurrentJobs,\n      });\n      \n      // Wire scheduler into delivery coordinator\n      this.deliveryCoordinator = new DeliveryCoordinator({\n        transport: this.transport,\n        apnsDelivery: this.apnsDelivery,\n        schedulerService: this.schedulerService,  // NEW\n      });\n    } else {\n      // No scheduling - use existing coordinator\n      this.deliveryCoordinator = new DeliveryCoordinator({\n        transport: this.transport,\n        apnsDelivery: this.apnsDelivery,\n      });\n    }\n  }\n  \n  async start(): Promise<void> {\n    await this.transport.start();\n    \n    // NEW: Start scheduler if enabled\n    if (this.schedulerService) {\n      await this.schedulerService.start();\n    }\n  }\n  \n  async stop(): Promise<void> {\n    // NEW: Stop scheduler\n    if (this.schedulerService) {\n      await this.schedulerService.stop();\n    }\n    \n    await this.transport.stop();\n  }\n}\n```\n\n---\n\n## **6. Client SDK Changes**\n\n### **6.1 New Subscription Methods**\n\n```typescript\n// packages/client/src/client/asp-client.ts\n\nexport class ASPClient {\n  /**\n   * NEW: Create a cron-based subscription\n   */\n  async subscribeWithCron(\n    filter: EventFilter,\n    cronExpression: string,\n    options?: {\n      timezone?: string;\n      startDate?: Date;\n      endDate?: Date;\n      maxOccurrences?: number;\n      deliveryChannels?: DeliveryChannel[];  // Where to deliver when triggered\n    }\n  ): Promise<Subscription> {\n    return this.subscribe({\n      filter,\n      delivery: {\n        channels: ['cron', ...(options?.deliveryChannels || ['websocket'])],\n        schedule: {\n          type: 'cron',\n          expression: cronExpression,\n          timezone: options?.timezone,\n          startDate: options?.startDate?.toISOString(),\n          endDate: options?.endDate?.toISOString(),\n          maxOccurrences: options?.maxOccurrences,\n        },\n      },\n    });\n  }\n  \n  /**\n   * NEW: Create a one-time scheduled subscription\n   */\n  async scheduleFor(\n    filter: EventFilter,\n    when: Date | string,  // Date object or natural language\n    options?: {\n      deliveryChannels?: DeliveryChannel[];\n    }\n  ): Promise<Subscription> {\n    let executeAt: string;\n    \n    if (typeof when === 'string') {\n      // Parse natural language\n      executeAt = await this.parseNaturalLanguage(when);\n    } else {\n      executeAt = when.toISOString();\n    }\n    \n    return this.subscribe({\n      filter,\n      delivery: {\n        channels: ['scheduled', ...(options?.deliveryChannels || ['websocket'])],\n        schedule: {\n          type: 'onetime',\n          executeAt,\n          naturalLanguage: typeof when === 'string' ? when : undefined,\n        },\n      },\n    });\n  }\n  \n  /**\n   * NEW: List active schedules for this client\n   */\n  async listSchedules(): Promise<Schedule[]> {\n    return this.request('schedules/list', {});\n  }\n  \n  /**\n   * NEW: Cancel a scheduled job\n   */\n  async cancelSchedule(scheduleId: string): Promise<boolean> {\n    const result = await this.request('schedules/cancel', { scheduleId });\n    return result.success;\n  }\n  \n  /**\n   * NEW: Pause a recurring schedule\n   */\n  async pauseSchedule(scheduleId: string): Promise<boolean> {\n    const result = await this.request('schedules/pause', { scheduleId });\n    return result.success;\n  }\n  \n  /**\n   * NEW: Resume a paused schedule\n   */\n  async resumeSchedule(scheduleId: string): Promise<boolean> {\n    const result = await this.request('schedules/resume', { scheduleId });\n    return result.success;\n  }\n}\n```\n\n---\n\n## **7. New Protocol Methods**\n\n```typescript\n// packages/core/src/types/messages.ts - NEW METHODS\n\n// Schedule Management\nexport const ScheduleListParamsSchema = z.object({\n  status: z.enum(['pending', 'active', 'paused', 'completed']).optional(),\n  type: z.enum(['cron', 'onetime']).optional(),\n});\n\nexport const ScheduleListResultSchema = z.object({\n  schedules: z.array(ScheduleSchema),\n});\n\nexport const ScheduleCancelParamsSchema = z.object({\n  scheduleId: z.string().uuid(),\n});\n\nexport const ScheduleCancelResultSchema = z.object({\n  success: z.boolean(),\n  schedule: ScheduleSchema.optional(),  // Returns cancelled schedule\n});\n\nexport const SchedulePauseParamsSchema = z.object({\n  scheduleId: z.string().uuid(),\n});\n\nexport const SchedulePauseResultSchema = z.object({\n  success: z.boolean(),\n  status: z.literal('paused'),\n});\n\nexport const ScheduleResumeParamsSchema = z.object({\n  scheduleId: z.string().uuid(),\n});\n\nexport const ScheduleResumeResultSchema = z.object({\n  success: z.boolean(),\n  status: z.literal('active'),\n  nextExecutionAt: z.string().datetime().optional(),\n});\n\n// Add to ASPMethods\nexport const ASPMethods = {\n  // ... existing methods\n  \n  // Schedule Management (NEW)\n  ScheduleList: 'schedules/list',\n  ScheduleCancel: 'schedules/cancel',\n  SchedulePause: 'schedules/pause',\n  ScheduleResume: 'schedules/resume',\n} as const;\n```\n\n---\n\n## **8. Usage Examples**\n\n### **8.1 Cron-Based Subscription**\n\n```typescript\n// Client: \"Send me a daily summary at 9am on weekdays\"\n\nconst subscription = await client.subscribeWithCron(\n  { sources: ['summary'], eventTypes: ['daily.digest'] },\n  '0 9 * * 1-5',  // 9am, Monday-Friday\n  {\n    timezone: 'America/New_York',\n    deliveryChannels: ['webpush', 'email'],  // Deliver via push AND email\n    endDate: new Date('2025-12-31'),         // Stop after this year\n  }\n);\n\n// Server will:\n// 1. Save schedule to ScheduleStore\n// 2. Queue first execution for next 9am weekday\n// 3. At 9am, create synthetic event\n// 4. Deliver through webpush + email\n// 5. Re-queue for next weekday\n```\n\n### **8.2 One-Time Scheduled Subscription**\n\n```typescript\n// Client: \"Remind me about this in 4 hours\"\n\nconst subscription = await client.scheduleFor(\n  { sources: ['reminder'], eventTypes: ['reminder.due'] },\n  'in 4 hours',\n  {\n    deliveryChannels: ['apns'],  // iOS notification\n  }\n);\n\n// OR with exact date\nconst subscription = await client.scheduleFor(\n  { sources: ['reminder'], eventTypes: ['meeting.start'] },\n  new Date('2025-01-20T14:00:00Z'),\n  {\n    deliveryChannels: ['webpush'],\n  }\n);\n```\n\n---\n\n## **9. Database Schema (for production)**\n\n```sql\n-- Schedule Store (PostgreSQL example)\n\nCREATE TABLE schedules (\n  id UUID PRIMARY KEY,\n  subscription_id UUID NOT NULL REFERENCES subscriptions(id) ON DELETE CASCADE,\n  client_id TEXT NOT NULL,\n  \n  type VARCHAR(20) NOT NULL CHECK (type IN ('cron', 'onetime')),\n  status VARCHAR(20) NOT NULL DEFAULT 'active',\n  \n  -- Cron fields\n  cron_expression TEXT,\n  timezone TEXT DEFAULT 'UTC',\n  last_executed_at TIMESTAMP,\n  next_execution_at TIMESTAMP,\n  execution_count INTEGER DEFAULT 0,\n  max_occurrences INTEGER,\n  \n  -- One-time fields\n  execute_at TIMESTAMP,\n  \n  -- Job queue integration\n  job_id TEXT,\n  \n  -- Metadata\n  created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n  updated_at TIMESTAMP NOT NULL DEFAULT NOW(),\n  \n  -- Indexes for performance\n  CONSTRAINT valid_cron CHECK (\n    (type = 'cron' AND cron_expression IS NOT NULL) OR\n    (type = 'onetime' AND cron_expression IS NULL)\n  )\n);\n\n-- Indexes\nCREATE INDEX idx_schedules_client ON schedules(client_id);\nCREATE INDEX idx_schedules_subscription ON schedules(subscription_id);\nCREATE INDEX idx_schedules_status ON schedules(status);\nCREATE INDEX idx_schedules_next_execution ON schedules(next_execution_at) \n  WHERE status = 'active';\nCREATE INDEX idx_schedules_execute_at ON schedules(execute_at) \n  WHERE type = 'onetime' AND status = 'pending';\n\n-- Cleanup job (run daily)\nDELETE FROM schedules \nWHERE status = 'completed' \n  AND updated_at < NOW() - INTERVAL '30 days';\n```\n\n---\n\n## **10. Dependencies to Add**\n\n| Package | Purpose | Where |\n|---------|---------|-------|\n| `cron-parser` | Parse cron expressions | `packages/server` |\n| `chrono-node` | Natural language date parsing | `packages/server` |\n| `bull` or `bullmq` | Redis-backed job queue | `packages/server` (optional) |\n| `node-cron` | Lightweight cron runner | `packages/server` (alternative to Bull) |\n| `luxon` or `date-fns-tz` | Timezone handling | `packages/server` |\n\n---\n\n## **11. Testing Strategy**\n\n```typescript\n// Test scenarios to implement\n\ndescribe('Time-Based Delivery', () => {\n  describe('Cron Channel', () => {\n    it('should schedule recurring daily at specific time');\n    it('should handle timezone conversions');\n    it('should stop after maxOccurrences reached');\n    it('should stop after endDate reached');\n    it('should handle DST transitions');\n    it('should resume paused schedules');\n    it('should execute missed schedules if within tolerance');\n  });\n  \n  describe('Scheduled Channel', () => {\n    it('should parse \"in 4 hours\" correctly');\n    it('should parse \"next Sunday\" correctly');\n    it('should handle exact ISO timestamps');\n    it('should cancel before execution');\n    it('should mark as completed after execution');\n  });\n  \n  describe('Integration', () => {\n    it('should deliver synthetic event through WebSocket');\n    it('should deliver synthetic event through APNS');\n    it('should handle multiple delivery channels');\n    it('should cleanup completed schedules');\n  });\n});\n```\n\n---\n\n## **Summary: What Files Change**\n\n| File | Change Type | Description |\n|------|-------------|-------------|\n| `packages/core/src/types/subscriptions.ts` | Modify | Add `cron` and `scheduled` to `DeliveryChannelSchema` |\n| `packages/core/src/types/subscriptions.ts` | Add | `ScheduleConfigSchema`, `CronScheduleSchema`, `OneTimeScheduleSchema` |\n| `packages/core/src/types/schedules.ts` | Create | `Schedule` interface, `ScheduleStore` interface |\n| `packages/core/src/types/messages.ts` | Add | New method schemas for schedule management |\n| `packages/core/src/types/protocol.ts` | Modify | Add schedule methods to `ASPMethods` |\n| `packages/server/src/schedules/` | Create | Store implementations |\n| `packages/server/src/scheduler/` | Create | Scheduler service, cron evaluator, time parser |\n| `packages/server/src/delivery/coordinator.ts` | Modify | Add `scheduleForLater()` method |\n| `packages/server/src/hub/hub.ts` | Modify | Add scheduler setup and lifecycle |\n| `packages/server/src/index.ts` | Modify | Export new schedule types |\n| `packages/client/src/client/asp-client.ts` | Modify | Add convenience methods for time-based subscriptions |\n| `packages/client/src/index.ts` | Modify | Export new schedule types |\n\nThis plan provides a complete architecture for adding time-based delivery channels without implementing the code. The design integrates cleanly with the existing delivery coordinator pattern while adding the necessary infrastructure for delayed/recurring event delivery."
    },
    {
      "role": "user",
      "content": "i want to support only c"
    },
    {
      "role": "assistant",
      "content": " ",
      "tool_calls": [
        {
          "id": "  functions.update_todo_list:71",
          "type": "function",
          "function": {
            "name": "update_todo_list",
            "arguments": "{\"task_id\": \"task-e7028bdd\", \"status\": \"completed\", \"title\": \"Plan One-Time Scheduled Channel (SKIP - not needed)\", \"description\": \"User wants only cron-based channel, skipping one-time scheduled channel\"}"
          }
        }
      ]
    },
    {
      "role": "tool",
      "tool_call_id": "  functions.update_todo_list:71",
      "content": "{\"success\": true, \"data\": {\"task_id\": \"task-e7028bdd\", \"auto_created\": true, \"task\": {\"id\": \"task-e7028bdd\", \"title\": \"Plan One-Time Scheduled Channel (SKIP - not needed)\", \"description\": \"User wants only cron-based channel, skipping one-time scheduled channel\", \"status\": \"completed\"}, \"all_tasks\": [{\"id\": \"task-e7028bdd\", \"title\": \"Plan One-Time Scheduled Channel (SKIP - not needed)\", \"description\": \"User wants only cron-based channel, skipping one-time scheduled channel\", \"status\": \"completed\"}]}, \"error\": null, \"suggestions\": [], \"metadata\": {}}\n\n<todo-state>\nTasks: 1 completed, 0 in progress, 0 pending\n  task-e7028bdd. \u2705 Plan One-Time Scheduled Channel (SKIP - not needed)\n</todo-state>"
    },
    {
      "role": "assistant",
      "content": "  Got it! Here's a **simplified plan** for only the **cron-based delivery channel** (recurring schedules like \"every hour\", \"daily\", \"weekly\"):\n\n---\n\n## \ud83d\udccb SIMPLIFIED PLAN: Cron-Based Delivery Channel Only\n\n### **1. Minimal Protocol Changes**\n\n```typescript\n// packages/core/src/types/subscriptions.ts\n\n// Just add 'cron' to existing enum\nexport const DeliveryChannelSchema = z.enum([\n  'websocket',\n  'sse', \n  'webpush',\n  'apns',\n  'cron',        // \u2190 ONLY THIS ONE\n]);\n\n// Simple cron configuration (no one-time, no natural language)\nexport const CronScheduleSchema = z.object({\n  expression: z.string(),              // \"0 * * * *\" = every hour\n  timezone: z.string().optional(),     // \"America/New_York\" \n});\n\n// Extend DeliveryPreferences\nexport const DeliveryPreferencesSchema = z.object({\n  channels: z.array(DeliveryChannelSchema),\n  priority: DeliveryPrioritySchema.default('normal'),\n  cron: CronScheduleSchema.optional(),  // Only when channels includes 'cron'\n});\n```\n\n---\n\n### **2. Minimal New Components**\n\n```\npackages/server/src/\n\u251c\u2500\u2500 cron/\n\u2502   \u251c\u2500\u2500 schedule.ts          # CronSchedule interface (simpler than full Schedule)\n\u2502   \u251c\u2500\u2500 memory-store.ts      # In-memory store for cron schedules\n\u2502   \u251c\u2500\u2500 evaluator.ts         # Parse cron expressions (using cron-parser lib)\n\u2502   \u2514\u2500\u2500 runner.ts            # Simple interval-based runner\n```\n\n**No need for:**\n- \u274c Job queue (Bull/Agenda)\n- \u274c Complex ScheduleStore interface\n- \u274c Natural language parser\n- \u274c One-time schedule logic\n- \u274c Scheduler service\n\n---\n\n### **3. Simple CronRunner**\n\n```typescript\n// packages/server/src/cron/runner.ts\n\nexport class CronRunner {\n  private store: CronScheduleStore;\n  private interval: NodeJS.Timeout;\n  \n  constructor(options: {\n    store: CronScheduleStore;\n    checkInterval?: number;  // Default: 60000 (1 min)\n  }) {\n    this.store = options.store;\n  }\n  \n  start(): void {\n    // Simple polling approach\n    this.interval = setInterval(() => this.checkSchedules(), 60000);\n  }\n  \n  stop(): void {\n    clearInterval(this.interval);\n  }\n  \n  private async checkSchedules(): Promise<void> {\n    const now = new Date();\n    const dueSchedules = await this.store.getDue(now);\n    \n    for (const schedule of dueSchedules) {\n      // Create synthetic event\n      const event = this.createSyntheticEvent(schedule);\n      \n      // Deliver through coordinator\n      await this.deliver(event, schedule);\n      \n      // Update next execution time\n      const nextTime = this.getNextExecution(schedule.expression);\n      await this.store.updateNextExecution(schedule.id, nextTime);\n    }\n  }\n}\n```\n\n---\n\n### **4. Usage Example**\n\n```typescript\n// Client creates cron subscription\nconst subscription = await client.subscribe({\n  filter: { sources: ['report'], eventTypes: ['report.daily'] },\n  delivery: {\n    channels: ['cron', 'webpush'],  // Cron triggers, WebPush delivers\n    cron: {\n      expression: '0 9 * * 1-5',  // 9am weekdays\n      timezone: 'America/New_York',\n    },\n  },\n});\n\n// Server:\n// 1. Saves to CronScheduleStore\n// 2. CronRunner polls every minute\n// 3. At 9am Mon-Fri: creates event \u2192 delivers via WebPush\n```\n\n---\n\n### **5. Single Dependency**\n\n```json\n// packages/server/package.json\n{\n  \"dependencies\": {\n    \"cron-parser\": \"^4.9.0\"  // Only dependency needed\n  }\n}\n```\n\n---\n\n**Summary**: Minimal addition - just one new channel, one cron parser dependency, simple polling-based runner, no job queue complexity."
    }
  ],
  "model": "accounts/fireworks/models/kimi-k2p5",
  "mode": "code",
  "session_id": "1ea73373-a7df-4d92-9320-c4ea6fd3387b"
}