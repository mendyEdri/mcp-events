---
title: Subscribing
description: How to create subscriptions with filters, delivery options, and expiration.
---

## Creating a Subscription

The `subscribe()` method accepts a `CreateSubscriptionRequest`:

```typescript
interface CreateSubscriptionRequest {
  filter: EventFilter;
  delivery: DeliveryPreferences;
  handler?: EventHandler;
  expiresAt?: string;
}
```

### Minimal Subscription

Subscribe to all events with realtime delivery:

```typescript
const sub = await client.subscribe({
  filter: {},
  delivery: { channels: ["realtime"] },
});
```

### Filtered Subscription

```typescript
const sub = await client.subscribe({
  filter: {
    sources: ["github"],
    eventTypes: ["github.issue.*", "github.pull_request.*"],
    priority: ["high", "critical"],
    tags: ["frontend"],
  },
  delivery: { channels: ["realtime"] },
});
```

## Filter Patterns

### By Source

```typescript
filter: { sources: ["github", "slack"] }
```

### By Event Type

Exact match or wildcard:

```typescript
// Exact match
filter: { eventTypes: ["github.push"] }

// Wildcard — all issue events
filter: { eventTypes: ["github.issue.*"] }

// Multiple patterns
filter: { eventTypes: ["github.push", "github.issue.*", "slack.message"] }
```

### By Priority

```typescript
filter: { priority: ["high", "critical"] }
```

### By Tags

Tags use OR logic — an event matching **any** tag is included:

```typescript
filter: { tags: ["ci", "deploy", "production"] }
```

### Combined

All specified filters use AND logic:

```typescript
// High-priority GitHub events tagged with "ci"
filter: {
  sources: ["github"],
  priority: ["high", "critical"],
  tags: ["ci"],
}
```

## Delivery Options

### Realtime

Events arrive immediately:

```typescript
delivery: { channels: ["realtime"] }
```

### Cron Batching

Events are collected and delivered on a schedule:

```typescript
delivery: {
  channels: ["cron"],
  cronSchedule: {
    expression: "0 9 * * *",          // Daily at 9 AM
    timezone: "America/New_York",
    aggregateEvents: true,
    maxEventsPerDelivery: 100,
  },
}
```

### Scheduled (One-Time)

Events are delivered at a specific time:

```typescript
delivery: {
  channels: ["scheduled"],
  scheduledDelivery: {
    deliverAt: "2025-01-15T14:00:00Z",
    autoExpire: true,
  },
}
```

## Expiration

Set an expiration time to auto-remove the subscription:

```typescript
const sub = await client.subscribe({
  filter: { sources: ["github"] },
  delivery: { channels: ["realtime"] },
  expiresAt: "2025-02-01T00:00:00Z",
});

// Listen for expiration
client.onSubscriptionExpired((id) => {
  console.log(`Subscription ${id} has expired`);
});
```

## Handling Events

### Pattern-Based Handlers

`onEvent()` uses glob-style pattern matching:

```typescript
// All events
client.onEvent("*", (event) => { /* ... */ });

// All GitHub events
client.onEvent("github.*", (event) => { /* ... */ });

// Specific event type
client.onEvent("github.issue.opened", (event) => { /* ... */ });
```

Multiple handlers can match the same event — they all execute.

### Unregistering Handlers

`onEvent()` returns an unsubscribe function:

```typescript
const off = client.onEvent("github.*", handler);

// Later: stop handling
off();
```

### Clearing All Handlers

```typescript
client.clearHandlers();
```

## Subscription Management

### List Active Subscriptions

```typescript
const result = await client.listSubscriptions("active");
for (const sub of result.subscriptions) {
  console.log(`${sub.id} [${sub.status}]`, sub.filter);
}
```

### Pause and Resume

```typescript
await client.pause(subscriptionId);
// Events stop arriving

await client.resume(subscriptionId);
// Events start arriving again
```

### Update

Modify filter, delivery, or handler:

```typescript
await client.update(subscriptionId, {
  filter: {
    sources: ["github", "slack"],
    priority: ["critical"],
  },
});
```

### Unsubscribe

```typescript
const removed = await client.unsubscribe(subscriptionId);
// removed: true
```

## Subscribe Result

`subscribe()` returns a `SubscribeResult`:

```typescript
interface SubscribeResult {
  subscriptionId: string;
  status: string;
  filter: EventFilter;
  delivery: DeliveryPreferences;
  createdAt: string;
  expiresAt?: string;
}
```
