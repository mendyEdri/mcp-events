---
title: Publishing Events
description: How to publish events and route them to matching subscriptions.
---

## Publishing

`EventsServer.publish()` sends an event to all subscriptions whose filter matches the event.

### Shorthand Form

Pass the type, data, and metadata separately. The server auto-generates the event ID and timestamp.

```typescript
await server.publish(
  "github.issue.opened",
  {
    title: "Bug report: login crash",
    repo: "org/frontend",
    number: 123,
  },
  {
    source: "github",
    priority: "high",
    tags: ["bug", "frontend"],
  }
);
```

### Full Event Form

Pass a complete `MCPEvent` object:

```typescript
import { createEvent } from "@mcpe/core";

const event = createEvent(
  "slack.message",
  { channel: "#alerts", text: "Deploy completed", user: "bot" },
  { source: "slack", priority: "normal" }
);

await server.publish(event);
```

## Event Routing

When `publish()` is called, the server:

1. Finds all active subscriptions whose filter matches the event
2. For each matching subscription:
   - **Realtime**: Sends `events/event` notification immediately
   - **Cron**: Queues the event for the next scheduled delivery
   - **Scheduled**: Queues the event for the scheduled delivery time
3. If the subscription has a handler, executes it

```typescript
// This event matches subscriptions with:
//   - sources: ["github"]
//   - eventTypes: ["github.issue.*"] or ["github.*"]
//   - priority: ["high"] or ["high", "critical"]
//   - tags: ["bug"] or ["frontend"]
await server.publish("github.issue.opened", data, {
  source: "github",
  priority: "high",
  tags: ["bug", "frontend"],
});
```

## Batch Delivery

For cron and scheduled subscriptions, send events as a batch:

```typescript
await server.sendBatch(events, subscriptionId);
```

This sends an `events/batch` notification with all events in a single message.

## Integrating with External Sources

A common pattern is to bridge external webhooks or APIs to MCPE events:

### GitHub Webhooks

```typescript
import express from "express";

const app = express();
app.post("/webhook/github", express.json(), async (req, res) => {
  const { action, repository } = req.body;

  await server.publish(
    `github.${req.headers["x-github-event"]}.${action}`,
    req.body,
    {
      source: "github",
      sourceEventId: req.headers["x-github-delivery"] as string,
      priority: inferPriority(req.body),
      tags: [repository.full_name],
    }
  );

  res.sendStatus(200);
});
```

### Polling Adapter

```typescript
async function pollSlackMessages() {
  const messages = await slack.getNewMessages("#general");
  for (const msg of messages) {
    await server.publish("slack.message", msg, {
      source: "slack",
      priority: "normal",
    });
  }
}

setInterval(pollSlackMessages, 5000);
```

## Handler Execution

When a subscription includes a `handler`, the server automatically processes events through it. Three handler types are supported:

### Bash Handler

Executes a shell command with event data:

```typescript
// Subscription created by client with:
handler: {
  type: "bash",
  command: "notify-send",
  args: ["Alert", "$MCPE_EVENT_TYPE"],
  input: "env",     // Pass event as env vars
  timeout: 30000,   // 30s timeout
}
```

The event is passed based on the `input` mode:
- `"stdin"` - Event JSON piped to stdin
- `"env"` - Event fields as `MCPE_*` environment variables
- `"args"` - Event fields interpolated into args

### Webhook Handler

POSTs the event to an HTTP endpoint:

```typescript
handler: {
  type: "webhook",
  url: "https://api.example.com/events",
  headers: { "Authorization": "Bearer token" },
  timeout: 10000,
}
```

### Agent Handler

Delegates event processing to an LLM:

```typescript
handler: {
  type: "agent",
  systemPrompt: "Triage this GitHub issue and assign a priority label.",
  model: "claude-3-sonnet",
  tools: ["github_add_label", "github_assign"],
}
```

## Subscription Expiration

Notify clients when a subscription has expired:

```typescript
await server.notifySubscriptionExpired(subscriptionId);
```

This sends an `events/subscription_expired` notification. The server's scheduler automatically calls this when subscriptions reach their `expiresAt` time.
